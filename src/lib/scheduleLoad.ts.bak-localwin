import { capacityTierFor, saturationFor, CapacityTier } from "./airports";
import { fetchDeparturesAround } from "./aerodatabox";
import { estimateSecurityWaitMinutes } from "./security";
import { iataToIcao } from "./icao";

/** Internal (raw) busyness */
export type ScheduleBusyness = {
  departuresInWindow: number;   // 0 when none
  busynessPercent: number;      // 1..100 for schedule/heuristic (never 0 to avoid falsy UI)
  source: "schedule+load" | "heuristic";
  note?: string;
};

function clamp(n: number, lo: number, hi: number) { return Math.min(hi, Math.max(lo, n)); }

function normalizeISO(s: string): string {
  let t = (s || "").trim();
  t = t.replace(/^(\d{4}-\d{2}-\d{2})\s+/, "$1T");
  if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(t)) t += ":00";
  return t;
}

function pickDepartureISO(f: any): string | null {
  const cand = [
    f?.movement?.scheduledTimeLocal,
    f?.movement?.scheduledTimeUtc,
    f?.departure?.scheduledTimeLocal,
    f?.departure?.scheduledTimeUtc,
    f?.time?.scheduled?.departure?.local,
    f?.time?.scheduled?.departure?.utc,
  ];
  for (const c of cand) if (c && typeof c === "string") return normalizeISO(c);
  return null;
}

function withinMinutes(aISO: string, bISO: string, windowMin: number): boolean {
  const a = new Date(aISO).getTime();
  const b = new Date(normalizeISO(bISO)).getTime();
  if (!Number.isFinite(a) || !Number.isFinite(b)) return false;
  return Math.abs(a - b) / 60000 <= windowMin;
}

function hourOfLocal(iso: string): number {
  const d = new Date(normalizeISO(iso));
  return Number.isFinite(d.getTime()) ? d.getHours() : 12;
}

/** Hour-of-day curve -> 0..100, nudged by capacity tier */
function hourlyPercentHeuristic(depLocalISO: string, tier: CapacityTier): number {
  const h = hourOfLocal(depLocalISO);
  let base =
    (h >= 5 && h < 7)  ? 60 :
    (h >= 7 && h < 10) ? 75 :
    (h >= 10 && h < 13)? 60 :
    (h >= 13 && h < 16)? 65 :
    (h >= 16 && h < 19)? 75 :
    (h >= 19 && h < 22)? 50 :
                         25;
  const tierBump = { micro: -10, small: -5, medium: 0, large: 5, mega: 10 } as Record<CapacityTier, number>;
  base = clamp(base + (tierBump[tier] ?? 0), 0, 100);
  return base;
}

/** Busyness using ADB ±6h window around the requested time; falls back to heuristic if ADB empty. */
export async function getScheduleBusyness(
  airportIata: string,
  depLocalISO: string,
  windowMin = 90
): Promise<ScheduleBusyness> {
  const icao = iataToIcao(airportIata);
  const tier = capacityTierFor(airportIata);

  // No ICAO => heuristic
  if (!icao) {
    const pct = hourlyPercentHeuristic(depLocalISO, tier);
    const shown = clamp(Math.max(1, Math.round(pct)), 1, 100);
    console.warn("[SCHED] no ICAO mapping — heuristic", { airportIata, shown });
    return { departuresInWindow: 0, busynessPercent: shown, source: "heuristic", note: "no ICAO mapping" };
  }

  // Query around the target local time (±6h in UTC), then filter to ±windowMin locally
  const list = await fetchDeparturesAround(icao, depLocalISO, 6);

  if (!list || list.length === 0) {
    const pct = hourlyPercentHeuristic(depLocalISO, tier);
    const shown = clamp(Math.max(1, Math.round(pct)), 1, 100);
    console.warn("[SCHED] empty/no ADB schedule — heuristic", { icao, depLocalISO, shown });
    return { departuresInWindow: 0, busynessPercent: shown, source: "heuristic", note: "no schedule data" };
  }

  const inWindow = list.filter((f) => {
    const when = pickDepartureISO(f);
    return when ? withinMinutes(when, depLocalISO, windowMin) : false;
  });

  const count = inWindow.length;
  const sat   = saturationFor(tier);
  const rawPercent = clamp(Math.round((count / sat) * 100), 0, 100);
  const shown = clamp(rawPercent === 0 ? 1 : rawPercent, 1, 100);

  console.info("[SCHED] schedule window", { airportIata, icao, depLocalISO, count, windowMin, percent: shown });
  return { departuresInWindow: count, busynessPercent: shown, source: "schedule+load", note: "schedule+load" };
}

/** Legacy shape compute.ts expects */
type LegacyBusynessOut = { source: string; count: number; score: number; capacityTier: CapacityTier; windowMin: number; };

function toLegacyBusyness(airportIata: string, sb: ScheduleBusyness, windowMin: number): LegacyBusynessOut {
  const tier = capacityTierFor(airportIata);
  return {
    source: sb.source,
    count: sb.departuresInWindow,
    score: sb.busynessPercent,
    capacityTier: tier,
    windowMin,
  };
}

export async function predictSecurityFromScheduleWithLoad(
  airportOrObj: any,
  depMaybe?: string,
  optsMaybe?: any
): Promise<{ minutes: number; detail: string; busyness: LegacyBusynessOut; meta: any }> {
  const WINDOW = 90;

  let airport = "";
  let depLocalISO = "";
  let options: any = {};
  if (typeof airportOrObj === "string") {
    airport = airportOrObj;
    depLocalISO = String(depMaybe);
    options = optsMaybe || {};
  } else if (airportOrObj && typeof airportOrObj === "object") {
    airport = airportOrObj.airport || airportOrObj.airportIata || "";
    depLocalISO = airportOrObj.depLocalISO || airportOrObj.depTimeLocalISO || "";
    options = airportOrObj.options || {};
  }

  const base = estimateSecurityWaitMinutes(airport, depLocalISO, !!options?.trustedTraveler);
  const sb = await getScheduleBusyness(airport, depLocalISO, WINDOW);
  const legacy = toLegacyBusyness(airport, sb, WINDOW);

  // map 1..100 busyness -> ~0.7x..1.3x multiplier
  const factor = 0.7 + (sb.busynessPercent / 100) * 0.6;
  const minutes = clamp(Math.round(base * factor), 5, 120);

  const detail =
    sb.source === "schedule+load"
      ? `schedule+load (${sb.busynessPercent}% · ${sb.departuresInWindow} deps in ±${WINDOW}m)`
      : `heuristic (${sb.busynessPercent}% by hour-of-day)`;

  return {
    minutes,
    detail,
    busyness: legacy,
    meta: {
      securitySource: "estimate",
      securityDetail: detail,
      busynessPercent: sb.busynessPercent,     // guaranteed >= 1
      departuresInWindow: sb.departuresInWindow,
      busynessSource: sb.source,
    },
  };
}
